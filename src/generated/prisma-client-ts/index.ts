// Code generated by Prisma (prisma@1.26.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  customerCartItem: (where?: CustomerCartItemWhereInput) => Promise<boolean>;
  entityAbstract: (where?: EntityAbstractWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productVariant: (where?: ProductVariantWhereInput) => Promise<boolean>;
  storeManager: (where?: StoreManagerWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  customer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  customerCartItem: (
    where: CustomerCartItemWhereUniqueInput
  ) => CustomerCartItemPromise;
  customerCartItems: (args?: {
    where?: CustomerCartItemWhereInput;
    orderBy?: CustomerCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CustomerCartItem>;
  customerCartItemsConnection: (args?: {
    where?: CustomerCartItemWhereInput;
    orderBy?: CustomerCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerCartItemConnectionPromise;
  entityAbstract: (
    where: EntityAbstractWhereUniqueInput
  ) => EntityAbstractPromise;
  entityAbstracts: (args?: {
    where?: EntityAbstractWhereInput;
    orderBy?: EntityAbstractOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EntityAbstract>;
  entityAbstractsConnection: (args?: {
    where?: EntityAbstractWhereInput;
    orderBy?: EntityAbstractOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntityAbstractConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantPromise;
  productVariants: (args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductVariant>;
  productVariantsConnection: (args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductVariantConnectionPromise;
  storeManager: (where: StoreManagerWhereUniqueInput) => StoreManagerPromise;
  storeManagers: (args?: {
    where?: StoreManagerWhereInput;
    orderBy?: StoreManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StoreManager>;
  storeManagersConnection: (args?: {
    where?: StoreManagerWhereInput;
    orderBy?: StoreManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StoreManagerConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createCustomerCartItem: (
    data: CustomerCartItemCreateInput
  ) => CustomerCartItemPromise;
  updateCustomerCartItem: (args: {
    data: CustomerCartItemUpdateInput;
    where: CustomerCartItemWhereUniqueInput;
  }) => CustomerCartItemPromise;
  updateManyCustomerCartItems: (args: {
    data: CustomerCartItemUpdateManyMutationInput;
    where?: CustomerCartItemWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomerCartItem: (args: {
    where: CustomerCartItemWhereUniqueInput;
    create: CustomerCartItemCreateInput;
    update: CustomerCartItemUpdateInput;
  }) => CustomerCartItemPromise;
  deleteCustomerCartItem: (
    where: CustomerCartItemWhereUniqueInput
  ) => CustomerCartItemPromise;
  deleteManyCustomerCartItems: (
    where?: CustomerCartItemWhereInput
  ) => BatchPayloadPromise;
  createEntityAbstract: (
    data: EntityAbstractCreateInput
  ) => EntityAbstractPromise;
  updateEntityAbstract: (args: {
    data: EntityAbstractUpdateInput;
    where: EntityAbstractWhereUniqueInput;
  }) => EntityAbstractPromise;
  updateManyEntityAbstracts: (args: {
    data: EntityAbstractUpdateManyMutationInput;
    where?: EntityAbstractWhereInput;
  }) => BatchPayloadPromise;
  upsertEntityAbstract: (args: {
    where: EntityAbstractWhereUniqueInput;
    create: EntityAbstractCreateInput;
    update: EntityAbstractUpdateInput;
  }) => EntityAbstractPromise;
  deleteEntityAbstract: (
    where: EntityAbstractWhereUniqueInput
  ) => EntityAbstractPromise;
  deleteManyEntityAbstracts: (
    where?: EntityAbstractWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductVariant: (
    data: ProductVariantCreateInput
  ) => ProductVariantPromise;
  updateProductVariant: (args: {
    data: ProductVariantUpdateInput;
    where: ProductVariantWhereUniqueInput;
  }) => ProductVariantPromise;
  updateManyProductVariants: (args: {
    data: ProductVariantUpdateManyMutationInput;
    where?: ProductVariantWhereInput;
  }) => BatchPayloadPromise;
  upsertProductVariant: (args: {
    where: ProductVariantWhereUniqueInput;
    create: ProductVariantCreateInput;
    update: ProductVariantUpdateInput;
  }) => ProductVariantPromise;
  deleteProductVariant: (
    where: ProductVariantWhereUniqueInput
  ) => ProductVariantPromise;
  deleteManyProductVariants: (
    where?: ProductVariantWhereInput
  ) => BatchPayloadPromise;
  createStoreManager: (data: StoreManagerCreateInput) => StoreManagerPromise;
  updateStoreManager: (args: {
    data: StoreManagerUpdateInput;
    where: StoreManagerWhereUniqueInput;
  }) => StoreManagerPromise;
  updateManyStoreManagers: (args: {
    data: StoreManagerUpdateManyMutationInput;
    where?: StoreManagerWhereInput;
  }) => BatchPayloadPromise;
  upsertStoreManager: (args: {
    where: StoreManagerWhereUniqueInput;
    create: StoreManagerCreateInput;
    update: StoreManagerUpdateInput;
  }) => StoreManagerPromise;
  deleteStoreManager: (
    where: StoreManagerWhereUniqueInput
  ) => StoreManagerPromise;
  deleteManyStoreManagers: (
    where?: StoreManagerWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  customerCartItem: (
    where?: CustomerCartItemSubscriptionWhereInput
  ) => CustomerCartItemSubscriptionPayloadSubscription;
  entityAbstract: (
    where?: EntityAbstractSubscriptionWhereInput
  ) => EntityAbstractSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productVariant: (
    where?: ProductVariantSubscriptionWhereInput
  ) => ProductVariantSubscriptionPayloadSubscription;
  storeManager: (
    where?: StoreManagerSubscriptionWhereInput
  ) => StoreManagerSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CustomerCartItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "savedForLater_ASC"
  | "savedForLater_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductVariantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isDefaultVariant_ASC"
  | "isDefaultVariant_DESC"
  | "title_ASC"
  | "title_DESC"
  | "listPrice_ASC"
  | "listPrice_DESC"
  | "salePrice_ASC"
  | "salePrice_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uid_ASC"
  | "uid_DESC"
  | "emailId_ASC"
  | "emailId_DESC"
  | "mobileNumber_ASC"
  | "mobileNumber_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EntityAbstractOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "typeName_ASC"
  | "typeName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StoreManagerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uid_ASC"
  | "uid_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface StoreManagerUpdateOneRequiredWithoutProductsInput {
  create?: StoreManagerCreateWithoutProductsInput;
  update?: StoreManagerUpdateWithoutProductsDataInput;
  upsert?: StoreManagerUpsertWithoutProductsInput;
  connect?: StoreManagerWhereUniqueInput;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  uid?: String;
  emailId?: String;
}>;

export interface ProductVariantUpsertWithoutCartedInInput {
  update: ProductVariantUpdateWithoutCartedInDataInput;
  create: ProductVariantCreateWithoutCartedInInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  variants_every?: ProductVariantWhereInput;
  variants_some?: ProductVariantWhereInput;
  variants_none?: ProductVariantWhereInput;
  owner?: StoreManagerWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface ProductCreateWithoutVariantsInput {
  name: String;
  description: String;
  tags?: ProductCreatetagsInput;
  owner: StoreManagerCreateOneWithoutProductsInput;
}

export interface ProductVariantUpdateWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput;
  data: ProductVariantUpdateWithoutProductDataInput;
}

export interface ProductCreatetagsInput {
  set?: String[] | String;
}

export interface CustomerCartItemUpsertWithWhereUniqueWithoutCustomerInput {
  where: CustomerCartItemWhereUniqueInput;
  update: CustomerCartItemUpdateWithoutCustomerDataInput;
  create: CustomerCartItemCreateWithoutCustomerInput;
}

export interface StoreManagerCreateOneWithoutProductsInput {
  create?: StoreManagerCreateWithoutProductsInput;
  connect?: StoreManagerWhereUniqueInput;
}

export interface EntityAbstractWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  typeName?: String;
  typeName_not?: String;
  typeName_in?: String[] | String;
  typeName_not_in?: String[] | String;
  typeName_lt?: String;
  typeName_lte?: String;
  typeName_gt?: String;
  typeName_gte?: String;
  typeName_contains?: String;
  typeName_not_contains?: String;
  typeName_starts_with?: String;
  typeName_not_starts_with?: String;
  typeName_ends_with?: String;
  typeName_not_ends_with?: String;
  AND?: EntityAbstractWhereInput[] | EntityAbstractWhereInput;
  OR?: EntityAbstractWhereInput[] | EntityAbstractWhereInput;
  NOT?: EntityAbstractWhereInput[] | EntityAbstractWhereInput;
}

export interface StoreManagerCreateWithoutProductsInput {
  uid: String;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface CustomerUpdateInput {
  uid?: String;
  emailId?: String;
  mobileNumber?: String;
  name?: String;
  cartItems?: CustomerCartItemUpdateManyWithoutCustomerInput;
}

export interface CustomerCartItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CustomerCartItemWhereInput;
  AND?:
    | CustomerCartItemSubscriptionWhereInput[]
    | CustomerCartItemSubscriptionWhereInput;
  OR?:
    | CustomerCartItemSubscriptionWhereInput[]
    | CustomerCartItemSubscriptionWhereInput;
  NOT?:
    | CustomerCartItemSubscriptionWhereInput[]
    | CustomerCartItemSubscriptionWhereInput;
}

export interface CustomerCartItemUpdateManyWithoutCustomerInput {
  create?:
    | CustomerCartItemCreateWithoutCustomerInput[]
    | CustomerCartItemCreateWithoutCustomerInput;
  delete?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
  connect?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
  set?: CustomerCartItemWhereUniqueInput[] | CustomerCartItemWhereUniqueInput;
  disconnect?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
  update?:
    | CustomerCartItemUpdateWithWhereUniqueWithoutCustomerInput[]
    | CustomerCartItemUpdateWithWhereUniqueWithoutCustomerInput;
  upsert?:
    | CustomerCartItemUpsertWithWhereUniqueWithoutCustomerInput[]
    | CustomerCartItemUpsertWithWhereUniqueWithoutCustomerInput;
  deleteMany?:
    | CustomerCartItemScalarWhereInput[]
    | CustomerCartItemScalarWhereInput;
  updateMany?:
    | CustomerCartItemUpdateManyWithWhereNestedInput[]
    | CustomerCartItemUpdateManyWithWhereNestedInput;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CustomerWhereInput;
  AND?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  OR?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
  NOT?: CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput;
}

export interface CustomerCartItemUpdateWithWhereUniqueWithoutCustomerInput {
  where: CustomerCartItemWhereUniqueInput;
  data: CustomerCartItemUpdateWithoutCustomerDataInput;
}

export interface CustomerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  uid?: String;
  uid_not?: String;
  uid_in?: String[] | String;
  uid_not_in?: String[] | String;
  uid_lt?: String;
  uid_lte?: String;
  uid_gt?: String;
  uid_gte?: String;
  uid_contains?: String;
  uid_not_contains?: String;
  uid_starts_with?: String;
  uid_not_starts_with?: String;
  uid_ends_with?: String;
  uid_not_ends_with?: String;
  emailId?: String;
  emailId_not?: String;
  emailId_in?: String[] | String;
  emailId_not_in?: String[] | String;
  emailId_lt?: String;
  emailId_lte?: String;
  emailId_gt?: String;
  emailId_gte?: String;
  emailId_contains?: String;
  emailId_not_contains?: String;
  emailId_starts_with?: String;
  emailId_not_starts_with?: String;
  emailId_ends_with?: String;
  emailId_not_ends_with?: String;
  mobileNumber?: String;
  mobileNumber_not?: String;
  mobileNumber_in?: String[] | String;
  mobileNumber_not_in?: String[] | String;
  mobileNumber_lt?: String;
  mobileNumber_lte?: String;
  mobileNumber_gt?: String;
  mobileNumber_gte?: String;
  mobileNumber_contains?: String;
  mobileNumber_not_contains?: String;
  mobileNumber_starts_with?: String;
  mobileNumber_not_starts_with?: String;
  mobileNumber_ends_with?: String;
  mobileNumber_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cartItems_every?: CustomerCartItemWhereInput;
  cartItems_some?: CustomerCartItemWhereInput;
  cartItems_none?: CustomerCartItemWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CustomerWhereInput[] | CustomerWhereInput;
  OR?: CustomerWhereInput[] | CustomerWhereInput;
  NOT?: CustomerWhereInput[] | CustomerWhereInput;
}

export interface CustomerCartItemUpdateWithoutCustomerDataInput {
  productVariant?: ProductVariantUpdateOneRequiredWithoutCartedInInput;
  quantity?: Int;
  savedForLater?: Boolean;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductVariantUpdateOneRequiredWithoutCartedInInput {
  create?: ProductVariantCreateWithoutCartedInInput;
  update?: ProductVariantUpdateWithoutCartedInDataInput;
  upsert?: ProductVariantUpsertWithoutCartedInInput;
  connect?: ProductVariantWhereUniqueInput;
}

export interface ProductUpsertWithWhereUniqueWithoutOwnerInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutOwnerDataInput;
  create: ProductCreateWithoutOwnerInput;
}

export interface ProductVariantUpdateWithoutCartedInDataInput {
  entityType?: EntityAbstractUpdateOneRequiredInput;
  product?: ProductUpdateOneRequiredWithoutVariantsInput;
  isDefaultVariant?: Boolean;
  title?: String;
  listPrice?: Float;
  salePrice?: Float;
}

export interface ProductUpdateWithoutOwnerDataInput {
  name?: String;
  description?: String;
  tags?: ProductUpdatetagsInput;
  variants?: ProductVariantUpdateManyWithoutProductInput;
}

export interface EntityAbstractUpdateOneRequiredInput {
  create?: EntityAbstractCreateInput;
  update?: EntityAbstractUpdateDataInput;
  upsert?: EntityAbstractUpsertNestedInput;
  connect?: EntityAbstractWhereUniqueInput;
}

export interface ProductUpdateManyWithoutOwnerInput {
  create?: ProductCreateWithoutOwnerInput[] | ProductCreateWithoutOwnerInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutOwnerInput[]
    | ProductUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutOwnerInput[]
    | ProductUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface EntityAbstractUpdateDataInput {
  typeName?: String;
}

export interface CustomerCartItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  customer?: CustomerWhereInput;
  productVariant?: ProductVariantWhereInput;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  savedForLater?: Boolean;
  savedForLater_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CustomerCartItemWhereInput[] | CustomerCartItemWhereInput;
  OR?: CustomerCartItemWhereInput[] | CustomerCartItemWhereInput;
  NOT?: CustomerCartItemWhereInput[] | CustomerCartItemWhereInput;
}

export interface EntityAbstractUpsertNestedInput {
  update: EntityAbstractUpdateDataInput;
  create: EntityAbstractCreateInput;
}

export interface ProductCreateWithoutOwnerInput {
  name: String;
  description: String;
  tags?: ProductCreatetagsInput;
  variants?: ProductVariantCreateManyWithoutProductInput;
}

export interface ProductUpdateOneRequiredWithoutVariantsInput {
  create?: ProductCreateWithoutVariantsInput;
  update?: ProductUpdateWithoutVariantsDataInput;
  upsert?: ProductUpsertWithoutVariantsInput;
  connect?: ProductWhereUniqueInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductUpdateWithoutVariantsDataInput {
  name?: String;
  description?: String;
  tags?: ProductUpdatetagsInput;
  owner?: StoreManagerUpdateOneRequiredWithoutProductsInput;
}

export interface ProductVariantUpdateManyMutationInput {
  isDefaultVariant?: Boolean;
  title?: String;
  listPrice?: Float;
  salePrice?: Float;
}

export interface ProductUpdatetagsInput {
  set?: String[] | String;
}

export type ProductVariantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CustomerCartItemUpdateWithoutProductVariantDataInput {
  customer?: CustomerUpdateOneRequiredWithoutCartItemsInput;
  quantity?: Int;
  savedForLater?: Boolean;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
  description?: String;
  tags?: ProductUpdatetagsInput;
}

export interface StoreManagerUpdateWithoutProductsDataInput {
  uid?: String;
}

export type StoreManagerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  uid?: String;
}>;

export interface StoreManagerUpsertWithoutProductsInput {
  update: StoreManagerUpdateWithoutProductsDataInput;
  create: StoreManagerCreateWithoutProductsInput;
}

export interface ProductVariantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isDefaultVariant?: Boolean;
  isDefaultVariant_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  listPrice?: Float;
  listPrice_not?: Float;
  listPrice_in?: Float[] | Float;
  listPrice_not_in?: Float[] | Float;
  listPrice_lt?: Float;
  listPrice_lte?: Float;
  listPrice_gt?: Float;
  listPrice_gte?: Float;
  salePrice?: Float;
  salePrice_not?: Float;
  salePrice_in?: Float[] | Float;
  salePrice_not_in?: Float[] | Float;
  salePrice_lt?: Float;
  salePrice_lte?: Float;
  salePrice_gt?: Float;
  salePrice_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput;
  OR?: ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput;
  NOT?: ProductVariantScalarWhereInput[] | ProductVariantScalarWhereInput;
}

export interface ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput;
  create: ProductCreateWithoutVariantsInput;
}

export interface CustomerCartItemUpsertWithWhereUniqueWithoutProductVariantInput {
  where: CustomerCartItemWhereUniqueInput;
  update: CustomerCartItemUpdateWithoutProductVariantDataInput;
  create: CustomerCartItemCreateWithoutProductVariantInput;
}

export interface StoreManagerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  uid?: String;
  uid_not?: String;
  uid_in?: String[] | String;
  uid_not_in?: String[] | String;
  uid_lt?: String;
  uid_lte?: String;
  uid_gt?: String;
  uid_gte?: String;
  uid_contains?: String;
  uid_not_contains?: String;
  uid_starts_with?: String;
  uid_not_starts_with?: String;
  uid_ends_with?: String;
  uid_not_ends_with?: String;
  products_every?: ProductWhereInput;
  products_some?: ProductWhereInput;
  products_none?: ProductWhereInput;
  AND?: StoreManagerWhereInput[] | StoreManagerWhereInput;
  OR?: StoreManagerWhereInput[] | StoreManagerWhereInput;
  NOT?: StoreManagerWhereInput[] | StoreManagerWhereInput;
}

export interface CustomerCreateInput {
  uid: String;
  emailId: String;
  mobileNumber?: String;
  name?: String;
  cartItems?: CustomerCartItemCreateManyWithoutCustomerInput;
}

export interface CustomerCartItemUpdateWithWhereUniqueWithoutProductVariantInput {
  where: CustomerCartItemWhereUniqueInput;
  data: CustomerCartItemUpdateWithoutProductVariantDataInput;
}

export interface CustomerCartItemCreateWithoutCustomerInput {
  productVariant: ProductVariantCreateOneWithoutCartedInInput;
  quantity: Int;
  savedForLater?: Boolean;
}

export interface CustomerCartItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  savedForLater?: Boolean;
  savedForLater_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CustomerCartItemScalarWhereInput[] | CustomerCartItemScalarWhereInput;
  OR?: CustomerCartItemScalarWhereInput[] | CustomerCartItemScalarWhereInput;
  NOT?: CustomerCartItemScalarWhereInput[] | CustomerCartItemScalarWhereInput;
}

export interface ProductVariantCreateWithoutCartedInInput {
  entityType: EntityAbstractCreateOneInput;
  product: ProductCreateOneWithoutVariantsInput;
  isDefaultVariant?: Boolean;
  title: String;
  listPrice: Float;
  salePrice: Float;
}

export interface CustomerCartItemUpdateManyWithWhereNestedInput {
  where: CustomerCartItemScalarWhereInput;
  data: CustomerCartItemUpdateManyDataInput;
}

export interface EntityAbstractCreateInput {
  typeName: String;
}

export interface CustomerCartItemUpdateManyDataInput {
  quantity?: Int;
  savedForLater?: Boolean;
}

export interface StoreManagerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StoreManagerWhereInput;
  AND?:
    | StoreManagerSubscriptionWhereInput[]
    | StoreManagerSubscriptionWhereInput;
  OR?:
    | StoreManagerSubscriptionWhereInput[]
    | StoreManagerSubscriptionWhereInput;
  NOT?:
    | StoreManagerSubscriptionWhereInput[]
    | StoreManagerSubscriptionWhereInput;
}

export interface CustomerUpdateManyMutationInput {
  uid?: String;
  emailId?: String;
  mobileNumber?: String;
  name?: String;
}

export interface EntityAbstractSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityAbstractWhereInput;
  AND?:
    | EntityAbstractSubscriptionWhereInput[]
    | EntityAbstractSubscriptionWhereInput;
  OR?:
    | EntityAbstractSubscriptionWhereInput[]
    | EntityAbstractSubscriptionWhereInput;
  NOT?:
    | EntityAbstractSubscriptionWhereInput[]
    | EntityAbstractSubscriptionWhereInput;
}

export interface CustomerCartItemUpdateManyWithoutProductVariantInput {
  create?:
    | CustomerCartItemCreateWithoutProductVariantInput[]
    | CustomerCartItemCreateWithoutProductVariantInput;
  delete?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
  connect?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
  set?: CustomerCartItemWhereUniqueInput[] | CustomerCartItemWhereUniqueInput;
  disconnect?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
  update?:
    | CustomerCartItemUpdateWithWhereUniqueWithoutProductVariantInput[]
    | CustomerCartItemUpdateWithWhereUniqueWithoutProductVariantInput;
  upsert?:
    | CustomerCartItemUpsertWithWhereUniqueWithoutProductVariantInput[]
    | CustomerCartItemUpsertWithWhereUniqueWithoutProductVariantInput;
  deleteMany?:
    | CustomerCartItemScalarWhereInput[]
    | CustomerCartItemScalarWhereInput;
  updateMany?:
    | CustomerCartItemUpdateManyWithWhereNestedInput[]
    | CustomerCartItemUpdateManyWithWhereNestedInput;
}

export interface StoreManagerUpdateManyMutationInput {
  uid?: String;
}

export interface ProductVariantUpdateWithoutProductDataInput {
  entityType?: EntityAbstractUpdateOneRequiredInput;
  isDefaultVariant?: Boolean;
  title?: String;
  listPrice?: Float;
  salePrice?: Float;
  cartedIn?: CustomerCartItemUpdateManyWithoutProductVariantInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface CustomerCartItemCreateInput {
  customer: CustomerCreateOneWithoutCartItemsInput;
  productVariant: ProductVariantCreateOneWithoutCartedInInput;
  quantity: Int;
  savedForLater?: Boolean;
}

export interface ProductUpdateWithWhereUniqueWithoutOwnerInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutOwnerDataInput;
}

export interface CustomerCreateOneWithoutCartItemsInput {
  create?: CustomerCreateWithoutCartItemsInput;
  connect?: CustomerWhereUniqueInput;
}

export interface StoreManagerUpdateInput {
  uid?: String;
  products?: ProductUpdateManyWithoutOwnerInput;
}

export interface CustomerCreateWithoutCartItemsInput {
  uid: String;
  emailId: String;
  mobileNumber?: String;
  name?: String;
}

export interface StoreManagerCreateInput {
  uid: String;
  products?: ProductCreateManyWithoutOwnerInput;
}

export interface CustomerCartItemUpdateInput {
  customer?: CustomerUpdateOneRequiredWithoutCartItemsInput;
  productVariant?: ProductVariantUpdateOneRequiredWithoutCartedInInput;
  quantity?: Int;
  savedForLater?: Boolean;
}

export interface ProductVariantCreateInput {
  entityType: EntityAbstractCreateOneInput;
  product: ProductCreateOneWithoutVariantsInput;
  isDefaultVariant?: Boolean;
  title: String;
  listPrice: Float;
  salePrice: Float;
  cartedIn?: CustomerCartItemCreateManyWithoutProductVariantInput;
}

export interface CustomerUpdateOneRequiredWithoutCartItemsInput {
  create?: CustomerCreateWithoutCartItemsInput;
  update?: CustomerUpdateWithoutCartItemsDataInput;
  upsert?: CustomerUpsertWithoutCartItemsInput;
  connect?: CustomerWhereUniqueInput;
}

export interface ProductVariantUpdateManyWithWhereNestedInput {
  where: ProductVariantScalarWhereInput;
  data: ProductVariantUpdateManyDataInput;
}

export interface CustomerUpdateWithoutCartItemsDataInput {
  uid?: String;
  emailId?: String;
  mobileNumber?: String;
  name?: String;
}

export interface ProductVariantCreateOneWithoutCartedInInput {
  create?: ProductVariantCreateWithoutCartedInInput;
  connect?: ProductVariantWhereUniqueInput;
}

export interface CustomerUpsertWithoutCartItemsInput {
  update: CustomerUpdateWithoutCartItemsDataInput;
  create: CustomerCreateWithoutCartItemsInput;
}

export interface ProductCreateOneWithoutVariantsInput {
  create?: ProductCreateWithoutVariantsInput;
  connect?: ProductWhereUniqueInput;
}

export interface CustomerCartItemUpdateManyMutationInput {
  quantity?: Int;
  savedForLater?: Boolean;
}

export interface ProductVariantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  entityType?: EntityAbstractWhereInput;
  product?: ProductWhereInput;
  isDefaultVariant?: Boolean;
  isDefaultVariant_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  listPrice?: Float;
  listPrice_not?: Float;
  listPrice_in?: Float[] | Float;
  listPrice_not_in?: Float[] | Float;
  listPrice_lt?: Float;
  listPrice_lte?: Float;
  listPrice_gt?: Float;
  listPrice_gte?: Float;
  salePrice?: Float;
  salePrice_not?: Float;
  salePrice_in?: Float[] | Float;
  salePrice_not_in?: Float[] | Float;
  salePrice_lt?: Float;
  salePrice_lte?: Float;
  salePrice_gt?: Float;
  salePrice_gte?: Float;
  cartedIn_every?: CustomerCartItemWhereInput;
  cartedIn_some?: CustomerCartItemWhereInput;
  cartedIn_none?: CustomerCartItemWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProductVariantWhereInput[] | ProductVariantWhereInput;
  OR?: ProductVariantWhereInput[] | ProductVariantWhereInput;
  NOT?: ProductVariantWhereInput[] | ProductVariantWhereInput;
}

export interface EntityAbstractUpdateInput {
  typeName?: String;
}

export type CustomerCartItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EntityAbstractUpdateManyMutationInput {
  typeName?: String;
}

export interface ProductCreateManyWithoutOwnerInput {
  create?: ProductCreateWithoutOwnerInput[] | ProductCreateWithoutOwnerInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface ProductCreateInput {
  name: String;
  description: String;
  tags?: ProductCreatetagsInput;
  variants?: ProductVariantCreateManyWithoutProductInput;
  owner: StoreManagerCreateOneWithoutProductsInput;
}

export interface ProductVariantUpdateManyDataInput {
  isDefaultVariant?: Boolean;
  title?: String;
  listPrice?: Float;
  salePrice?: Float;
}

export interface ProductVariantCreateManyWithoutProductInput {
  create?:
    | ProductVariantCreateWithoutProductInput[]
    | ProductVariantCreateWithoutProductInput;
  connect?: ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput;
}

export interface CustomerCartItemCreateManyWithoutCustomerInput {
  create?:
    | CustomerCartItemCreateWithoutCustomerInput[]
    | CustomerCartItemCreateWithoutCustomerInput;
  connect?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
}

export interface ProductVariantCreateWithoutProductInput {
  entityType: EntityAbstractCreateOneInput;
  isDefaultVariant?: Boolean;
  title: String;
  listPrice: Float;
  salePrice: Float;
  cartedIn?: CustomerCartItemCreateManyWithoutProductVariantInput;
}

export interface ProductVariantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductVariantWhereInput;
  AND?:
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput;
  OR?:
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput;
  NOT?:
    | ProductVariantSubscriptionWhereInput[]
    | ProductVariantSubscriptionWhereInput;
}

export interface ProductVariantUpdateManyWithoutProductInput {
  create?:
    | ProductVariantCreateWithoutProductInput[]
    | ProductVariantCreateWithoutProductInput;
  delete?: ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput;
  connect?: ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput;
  set?: ProductVariantWhereUniqueInput[] | ProductVariantWhereUniqueInput;
  disconnect?:
    | ProductVariantWhereUniqueInput[]
    | ProductVariantWhereUniqueInput;
  update?:
    | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    | ProductVariantUpdateWithWhereUniqueWithoutProductInput;
  upsert?:
    | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    | ProductVariantUpsertWithWhereUniqueWithoutProductInput;
  deleteMany?:
    | ProductVariantScalarWhereInput[]
    | ProductVariantScalarWhereInput;
  updateMany?:
    | ProductVariantUpdateManyWithWhereNestedInput[]
    | ProductVariantUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateInput {
  name?: String;
  description?: String;
  tags?: ProductUpdatetagsInput;
  variants?: ProductVariantUpdateManyWithoutProductInput;
  owner?: StoreManagerUpdateOneRequiredWithoutProductsInput;
}

export interface CustomerCartItemCreateWithoutProductVariantInput {
  customer: CustomerCreateOneWithoutCartItemsInput;
  quantity: Int;
  savedForLater?: Boolean;
}

export interface CustomerCartItemCreateManyWithoutProductVariantInput {
  create?:
    | CustomerCartItemCreateWithoutProductVariantInput[]
    | CustomerCartItemCreateWithoutProductVariantInput;
  connect?:
    | CustomerCartItemWhereUniqueInput[]
    | CustomerCartItemWhereUniqueInput;
}

export interface ProductUpdateManyDataInput {
  name?: String;
  description?: String;
  tags?: ProductUpdatetagsInput;
}

export interface EntityAbstractCreateOneInput {
  create?: EntityAbstractCreateInput;
  connect?: EntityAbstractWhereUniqueInput;
}

export interface ProductVariantUpsertWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput;
  update: ProductVariantUpdateWithoutProductDataInput;
  create: ProductVariantCreateWithoutProductInput;
}

export interface ProductVariantUpdateInput {
  entityType?: EntityAbstractUpdateOneRequiredInput;
  product?: ProductUpdateOneRequiredWithoutVariantsInput;
  isDefaultVariant?: Boolean;
  title?: String;
  listPrice?: Float;
  salePrice?: Float;
  cartedIn?: CustomerCartItemUpdateManyWithoutProductVariantInput;
}

export type EntityAbstractWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  typeName?: String;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface StoreManagerPreviousValues {
  id: ID_Output;
  uid: String;
}

export interface StoreManagerPreviousValuesPromise
  extends Promise<StoreManagerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uid: () => Promise<String>;
}

export interface StoreManagerPreviousValuesSubscription
  extends Promise<AsyncIterator<StoreManagerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uid: () => Promise<AsyncIterator<String>>;
}

export interface CustomerCartItemConnection {
  pageInfo: PageInfo;
  edges: CustomerCartItemEdge[];
}

export interface CustomerCartItemConnectionPromise
  extends Promise<CustomerCartItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerCartItemEdge>>() => T;
  aggregate: <T = AggregateCustomerCartItemPromise>() => T;
}

export interface CustomerCartItemConnectionSubscription
  extends Promise<AsyncIterator<CustomerCartItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerCartItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerCartItemSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  tags: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  tags: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductVariantPreviousValues {
  id: ID_Output;
  isDefaultVariant: Boolean;
  title: String;
  listPrice: Float;
  salePrice: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductVariantPreviousValuesPromise
  extends Promise<ProductVariantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isDefaultVariant: () => Promise<Boolean>;
  title: () => Promise<String>;
  listPrice: () => Promise<Float>;
  salePrice: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductVariantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isDefaultVariant: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  listPrice: () => Promise<AsyncIterator<Float>>;
  salePrice: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface StoreManagerEdge {
  node: StoreManager;
  cursor: String;
}

export interface StoreManagerEdgePromise
  extends Promise<StoreManagerEdge>,
    Fragmentable {
  node: <T = StoreManagerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StoreManagerEdgeSubscription
  extends Promise<AsyncIterator<StoreManagerEdge>>,
    Fragmentable {
  node: <T = StoreManagerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface Customer {
  id: ID_Output;
  uid: String;
  emailId: String;
  mobileNumber?: String;
  name?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  uid: () => Promise<String>;
  emailId: () => Promise<String>;
  mobileNumber: () => Promise<String>;
  name: () => Promise<String>;
  cartItems: <T = FragmentableArray<CustomerCartItem>>(args?: {
    where?: CustomerCartItemWhereInput;
    orderBy?: CustomerCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uid: () => Promise<AsyncIterator<String>>;
  emailId: () => Promise<AsyncIterator<String>>;
  mobileNumber: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  cartItems: <T = Promise<AsyncIterator<CustomerCartItemSubscription>>>(args?: {
    where?: CustomerCartItemWhereInput;
    orderBy?: CustomerCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductVariantSubscriptionPayload {
  mutation: MutationType;
  node: ProductVariant;
  updatedFields: String[];
  previousValues: ProductVariantPreviousValues;
}

export interface ProductVariantSubscriptionPayloadPromise
  extends Promise<ProductVariantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductVariantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductVariantPreviousValuesPromise>() => T;
}

export interface ProductVariantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductVariantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductVariantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductVariantPreviousValuesSubscription>() => T;
}

export interface ProductVariantEdge {
  node: ProductVariant;
  cursor: String;
}

export interface ProductVariantEdgePromise
  extends Promise<ProductVariantEdge>,
    Fragmentable {
  node: <T = ProductVariantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductVariantEdgeSubscription
  extends Promise<AsyncIterator<ProductVariantEdge>>,
    Fragmentable {
  node: <T = ProductVariantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StoreManager {
  id: ID_Output;
  uid: String;
}

export interface StoreManagerPromise
  extends Promise<StoreManager>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uid: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StoreManagerSubscription
  extends Promise<AsyncIterator<StoreManager>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uid: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerCartItem {
  id: ID_Output;
  quantity: Int;
  savedForLater: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerCartItemPromise
  extends Promise<CustomerCartItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  productVariant: <T = ProductVariantPromise>() => T;
  quantity: () => Promise<Int>;
  savedForLater: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerCartItemSubscription
  extends Promise<AsyncIterator<CustomerCartItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  productVariant: <T = ProductVariantSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  savedForLater: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface EntityAbstractEdge {
  node: EntityAbstract;
  cursor: String;
}

export interface EntityAbstractEdgePromise
  extends Promise<EntityAbstractEdge>,
    Fragmentable {
  node: <T = EntityAbstractPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntityAbstractEdgeSubscription
  extends Promise<AsyncIterator<EntityAbstractEdge>>,
    Fragmentable {
  node: <T = EntityAbstractSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  uid: String;
  emailId: String;
  mobileNumber?: String;
  name?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uid: () => Promise<String>;
  emailId: () => Promise<String>;
  mobileNumber: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uid: () => Promise<AsyncIterator<String>>;
  emailId: () => Promise<AsyncIterator<String>>;
  mobileNumber: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCustomerCartItem {
  count: Int;
}

export interface AggregateCustomerCartItemPromise
  extends Promise<AggregateCustomerCartItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerCartItemSubscription
  extends Promise<AsyncIterator<AggregateCustomerCartItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  description: String;
  tags: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  tags: () => Promise<String[]>;
  variants: <T = FragmentableArray<ProductVariant>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = StoreManagerPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  variants: <T = Promise<AsyncIterator<ProductVariantSubscription>>>(args?: {
    where?: ProductVariantWhereInput;
    orderBy?: ProductVariantOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = StoreManagerSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StoreManagerSubscriptionPayload {
  mutation: MutationType;
  node: StoreManager;
  updatedFields: String[];
  previousValues: StoreManagerPreviousValues;
}

export interface StoreManagerSubscriptionPayloadPromise
  extends Promise<StoreManagerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StoreManagerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StoreManagerPreviousValuesPromise>() => T;
}

export interface StoreManagerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StoreManagerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StoreManagerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StoreManagerPreviousValuesSubscription>() => T;
}

export interface CustomerCartItemSubscriptionPayload {
  mutation: MutationType;
  node: CustomerCartItem;
  updatedFields: String[];
  previousValues: CustomerCartItemPreviousValues;
}

export interface CustomerCartItemSubscriptionPayloadPromise
  extends Promise<CustomerCartItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerCartItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerCartItemPreviousValuesPromise>() => T;
}

export interface CustomerCartItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerCartItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerCartItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerCartItemPreviousValuesSubscription>() => T;
}

export interface StoreManagerConnection {
  pageInfo: PageInfo;
  edges: StoreManagerEdge[];
}

export interface StoreManagerConnectionPromise
  extends Promise<StoreManagerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StoreManagerEdge>>() => T;
  aggregate: <T = AggregateStoreManagerPromise>() => T;
}

export interface StoreManagerConnectionSubscription
  extends Promise<AsyncIterator<StoreManagerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StoreManagerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStoreManagerSubscription>() => T;
}

export interface CustomerCartItemPreviousValues {
  id: ID_Output;
  quantity: Int;
  savedForLater: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerCartItemPreviousValuesPromise
  extends Promise<CustomerCartItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  savedForLater: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerCartItemPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerCartItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  savedForLater: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductVariantConnection {
  pageInfo: PageInfo;
  edges: ProductVariantEdge[];
}

export interface ProductVariantConnectionPromise
  extends Promise<ProductVariantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductVariantEdge>>() => T;
  aggregate: <T = AggregateProductVariantPromise>() => T;
}

export interface ProductVariantConnectionSubscription
  extends Promise<AsyncIterator<ProductVariantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductVariantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductVariantSubscription>() => T;
}

export interface EntityAbstract {
  id: ID_Output;
  typeName: String;
}

export interface EntityAbstractPromise
  extends Promise<EntityAbstract>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  typeName: () => Promise<String>;
}

export interface EntityAbstractSubscription
  extends Promise<AsyncIterator<EntityAbstract>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  typeName: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEntityAbstract {
  count: Int;
}

export interface AggregateEntityAbstractPromise
  extends Promise<AggregateEntityAbstract>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntityAbstractSubscription
  extends Promise<AsyncIterator<AggregateEntityAbstract>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerCartItemEdge {
  node: CustomerCartItem;
  cursor: String;
}

export interface CustomerCartItemEdgePromise
  extends Promise<CustomerCartItemEdge>,
    Fragmentable {
  node: <T = CustomerCartItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerCartItemEdgeSubscription
  extends Promise<AsyncIterator<CustomerCartItemEdge>>,
    Fragmentable {
  node: <T = CustomerCartItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductVariant {
  id: ID_Output;
  isDefaultVariant: Boolean;
  title: String;
  listPrice: Float;
  salePrice: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductVariantPromise
  extends Promise<ProductVariant>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  entityType: <T = EntityAbstractPromise>() => T;
  product: <T = ProductPromise>() => T;
  isDefaultVariant: () => Promise<Boolean>;
  title: () => Promise<String>;
  listPrice: () => Promise<Float>;
  salePrice: () => Promise<Float>;
  cartedIn: <T = FragmentableArray<CustomerCartItem>>(args?: {
    where?: CustomerCartItemWhereInput;
    orderBy?: CustomerCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductVariantSubscription
  extends Promise<AsyncIterator<ProductVariant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  entityType: <T = EntityAbstractSubscription>() => T;
  product: <T = ProductSubscription>() => T;
  isDefaultVariant: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  listPrice: () => Promise<AsyncIterator<Float>>;
  salePrice: () => Promise<AsyncIterator<Float>>;
  cartedIn: <T = Promise<AsyncIterator<CustomerCartItemSubscription>>>(args?: {
    where?: CustomerCartItemWhereInput;
    orderBy?: CustomerCartItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EntityAbstractPreviousValues {
  id: ID_Output;
  typeName: String;
}

export interface EntityAbstractPreviousValuesPromise
  extends Promise<EntityAbstractPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  typeName: () => Promise<String>;
}

export interface EntityAbstractPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityAbstractPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  typeName: () => Promise<AsyncIterator<String>>;
}

export interface EntityAbstractSubscriptionPayload {
  mutation: MutationType;
  node: EntityAbstract;
  updatedFields: String[];
  previousValues: EntityAbstractPreviousValues;
}

export interface EntityAbstractSubscriptionPayloadPromise
  extends Promise<EntityAbstractSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntityAbstractPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityAbstractPreviousValuesPromise>() => T;
}

export interface EntityAbstractSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntityAbstractSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntityAbstractSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityAbstractPreviousValuesSubscription>() => T;
}

export interface AggregateStoreManager {
  count: Int;
}

export interface AggregateStoreManagerPromise
  extends Promise<AggregateStoreManager>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStoreManagerSubscription
  extends Promise<AsyncIterator<AggregateStoreManager>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityAbstractConnection {
  pageInfo: PageInfo;
  edges: EntityAbstractEdge[];
}

export interface EntityAbstractConnectionPromise
  extends Promise<EntityAbstractConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntityAbstractEdge>>() => T;
  aggregate: <T = AggregateEntityAbstractPromise>() => T;
}

export interface EntityAbstractConnectionSubscription
  extends Promise<AsyncIterator<EntityAbstractConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityAbstractEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntityAbstractSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductVariant {
  count: Int;
}

export interface AggregateProductVariantPromise
  extends Promise<AggregateProductVariant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductVariantSubscription
  extends Promise<AsyncIterator<AggregateProductVariant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "CustomerCartItem",
    embedded: false
  },
  {
    name: "EntityAbstract",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductVariant",
    embedded: false
  },
  {
    name: "StoreManager",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/kumar-gaurav/shield-fallback-deny/dev`
});
export const prisma = new Prisma();
